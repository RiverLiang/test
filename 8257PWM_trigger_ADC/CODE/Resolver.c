/** ###################################################################
**     THIS COMPONENT MODULE IS GENERATED BY THE TOOL. DO NOT MODIFY IT.
**     Filename  : Resolver.C
**     Project   : PmsmFocDrv
**     Processor : MC56F8257
**     Component : SynchroMaster
**     Version   : Component 02.322, Driver 02.02, CPU db: 3.00.231
**     Compiler  : Metrowerks DSP C Compiler
**     Date/Time : 2014/4/25, 9:32
**     Abstract  :
**         This bean "SynchroMaster" implements MASTER part of synchronous
**         serial master-slave communication.
**     Settings  :
**         Synchro type                : MASTER
**
**         Serial channel              : QSPI0
**
**         Protocol
**             Init baud rate          : 1_875MHz
**             Clock edge              : falling
**             Width                   : 12 bits
**             Empty character         : 8
**             Empty char. on input    : IGNORED
**
**         Registers
**             Input buffer            : QSPI0_DRCV [F202]
**             Output buffer           : QSPI0_DXMIT [F203]
**             Control register        : QSPI0_SCTRL [F200]
**             Mode register           : QSPI0_DSCTRL [F201]
**             Baud setting reg.       : QSPI0_SCTRL [F200]
**
**
**
**         Used pins                   :
**         ----------------------------------------------------------
**              Function    | On package |    Name
**         ----------------------------------------------------------
**               Input      |     33     |  GPIOC8_MISO_RXD0
**               Clock      |     34     |  GPIOC9_SCLK_XB_IN4
**           Select slave   |     32     |  GPIOC7_SS_TXD0
**         ----------------------------------------------------------
**
**     Contents  :
**         Enable          - byte Resolver_Enable(void);
**         Disable         - byte Resolver_Disable(void);
**         RecvChar        - byte Resolver_RecvChar(Resolver_TComData *Chr);
**         SendChar        - byte Resolver_SendChar(Resolver_TComData Chr);
**         GetCharsInRxBuf - word Resolver_GetCharsInRxBuf(void);
**         GetCharsInTxBuf - word Resolver_GetCharsInTxBuf(void);
**         PutSSVal        - void Resolver_PutSSVal(bool Val);
**
**     Copyright : 1997 - 2009 Freescale Semiconductor, Inc. All Rights Reserved.
**     
**     http      : www.freescale.com
**     mail      : support@freescale.com
** ###################################################################*/

/* MODULE Resolver. */

#include "Resolver.h"

#define OVERRUN_ERR      0x01          /* Overrun error flag bit   */
#define CHAR_IN_RX       0x08          /* Char is in RX buffer     */
#define FULL_TX          0x10          /* Full transmit buffer     */
#define RUNINT_FROM_TX   0x20          /* Interrupt is in progress */
#define FULL_RX          0x40          /* Full receive buffer      */

static bool EnUser;                    /* Enable/Disable SPI */
static byte SerFlag;                   /* Flags for serial communication */
                                       /* Bits: 0 - OverRun error */
                                       /*       1 - Unused */
                                       /*       2 - Unused */
                                       /*       3 - Char in RX buffer */
                                       /*       4 - Full TX buffer */
                                       /*       5 - Running int from TX */
                                       /*       6 - Full RX buffer */
                                       /*       7 - Unused */
static Resolver_TComData BufferWrite;  /* Output char SPI commmunication */

/*
** ===================================================================
**     Method      :  HWEnDi (component SynchroMaster)
**
**     Description :
**         Enables or disables the peripheral(s) associated with the bean.
**         The method is called automatically as a part of the Enable and 
**         Disable methods and several internal methods.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
static void HWEnDi(void)
{
  if (EnUser) {                        /* Enable device? */
    setRegBit(QSPI0_SCTRL,SPE);        /* Enable device */
    setRegBits(GPIO_C_PEREN,0x0200);   /* Switch pin to peripheral */
    if (SerFlag & FULL_TX) {           /* Is any char in transmit buffer? */
      setReg(QSPI0_DXMIT,BufferWrite); /* Store char to transmitter register */
      SerFlag &= ~FULL_TX;             /* Zeroize FULL_TX flag */
    }
  }
  else {
    clrRegBits(GPIO_C_PEREN,0x0200);   /* Switch pin to GPIO */
    clrRegBit(QSPI0_SCTRL,SPE);        /* Disable device */
  }
}

/*
** ===================================================================
**     Method      :  Resolver_Enable (component SynchroMaster)
**
**     Description :
**         Enable the bean - it starts send and receive functions.
**         Events may be generated ("DisableEvent"/"EnableEvent").
**     Parameters  : None
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
** ===================================================================
*/
byte Resolver_Enable(void)
{
  if (!EnUser) {                       /* Is the device disabled by user? */
    EnUser = TRUE;                     /* If yes then set the flag "device enabled" */
    HWEnDi();                          /* Enable the device */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  Resolver_Disable (component SynchroMaster)
**
**     Description :
**         Disable the bean - it stops the send and receive functions.
**         No events will be generated. Note: When this method is
**         called while a transmission is in progress, the data being
**         transmitted/received may be lost.
**     Parameters  : None
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
** ===================================================================
*/
byte Resolver_Disable(void)
{
  if (EnUser) {                        /* Is the device enabled by user? */
    EnUser = FALSE;                    /* If yes then set the flag "device disabled" */
    HWEnDi();                          /* Disable the device */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  Resolver_RecvChar (component SynchroMaster)
**
**     Description :
**         If any data is received, this method returns one character,
**         otherwise it returns an error code (it does not wait for
**         data).
**         Version specific information for Freescale 56800 derivatives
**         ] 
**         DMA mode:
**         If DMA controller is available on selected CPU and receiver
**         is configured to use DMA controller then this method only
**         sets the selected DMA channel. Status of the DMA transfer
**         can then be checked using method GetCharsInRxBuf. See
**         typical usage for details about communication using DMA.
**     Parameters  :
**         NAME            - DESCRIPTION
**       * Chr             - A pointer to the received character
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_RXEMPTY - No data in receiver
**                           ERR_OVERRUN - Overrun error was detected
**                           from the last char or block received. In
**                           polling mode, this error code is returned
**                           only when the hardware supports detection
**                           of the overrun error. 
**                           ERR_FAULT - Fault error was detected from
**                           the last char or block received. This error
**                           may not be supported on some CPUs (see
**                           generated code).
** ===================================================================
*/
byte Resolver_RecvChar(Resolver_TComData *Chr)
{
  register word Status;                                          

  Status = getReg(QSPI0_SCTRL);        /* Read the device error register */
  if (!(Status & QSPI0_SCTRL_SPRF_MASK)) { /* Is not received char? */
    return ERR_RXEMPTY;                /* If yes then error is returned */
  }
  *Chr = (Resolver_TComData)getReg(QSPI0_DRCV); /* Read data from receiver */
  if (*Chr == Resolver_EOF) {          /* Is received char same as empty char? */
    return ERR_RXEMPTY;                /* If yes then error is returned */
  }
  if (Status & QSPI0_SCTRL_OVRF_MASK) { /* Is the overrun error flag set? */
    return ERR_OVERRUN;                /* If yes then error is returned  */
  }
  return ERR_OK;
}

/*
** ===================================================================
**     Method      :  Resolver_SendChar (component SynchroMaster)
**
**     Description :
**         Sends one character to the channel.
**         Version specific information for Freescale 56800 derivatives
**         ] 
**         DMA mode:
**         If DMA controller is available on the selected CPU and the
**         transmitter is configured to use DMA controller then this
**         method only sets the selected DMA channel. The status of the
**         DMA transfer can then be checked using GetCharsInTxBuf
**         method. See the typical usage for details about
**         communication using DMA.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Chr             - Character to send
**     Returns     :
**         ---             - Error code, possible codes:
**                           ERR_OK - OK
**                           ERR_SPEED - This device does not work in
**                           the active speed mode
**                           ERR_DISABLED - Device is disabled (only if
**                           output DMA is supported and enabled)
**                           ERR_TXFULL - Transmitter is full
** ===================================================================
*/
byte Resolver_SendChar(Resolver_TComData Chr)
{
  if ((!getRegBit(QSPI0_SCTRL,SPTE))||(SerFlag&FULL_TX)) { /* Is last character send? */
    return ERR_TXFULL;                 /* If no then return error */
  }
  if (EnUser) {                        /* Is device enabled? */
    setReg(QSPI0_DXMIT,Chr);           /* If yes, send character */
  }
  else {
    BufferWrite = Chr;                 /* If no, save character */
    SerFlag |= FULL_TX;                /* ...and set flag */
  }
  return ERR_OK;                       /* OK */
}

/*
** ===================================================================
**     Method      :  Resolver_GetCharsInRxBuf (component SynchroMaster)
**
**     Description :
**         Returns the number of characters in the input buffer.
**         Note: If the Interrupt service is disabled, and the Ignore
**         empty character is set to yes, and a character has been
**         received, then this method returns 1 although it was an
**         empty character.
**         Version specific information for Freescale 56800 derivatives
**         ] 
**         DMA mode:
**         If DMA controller is available on the selected CPU and the
**         receiver is configured to use DMA controller then this
**         method returns the number of characters in the receive
**         buffer.
**     Parameters  : None
**     Returns     :
**         ---             - Number of characters in the input buffer.
** ===================================================================
*/
/*
word Resolver_GetCharsInRxBuf(void)

**      This method is implemented as a macro. See header module. **
*/

/*
** ===================================================================
**     Method      :  Resolver_GetCharsInTxBuf (component SynchroMaster)
**
**     Description :
**         Returns the number of characters in the output buffer.
**         Version specific information for Freescale 56800 derivatives
**         ] 
**         DMA mode:
**         If DMA controller is available on the selected CPU and the
**         transmitter is configured to use DMA controller then this
**         method returns the number of characters in the transmit
**         buffer.
**     Parameters  : None
**     Returns     :
**         ---             - Number of characters in the output buffer.
** ===================================================================
*/
word Resolver_GetCharsInTxBuf(void)
{
  return ((word)((EnUser) ? (getRegBit(QSPI0_SCTRL,SPTE)?0:1) : ((SerFlag & FULL_TX)?1:0))); /* Return number of chars in the transmit buffer */
}

/*
** ===================================================================
**     Method      :  Resolver_PutSSVal (component SynchroMaster)
**
**     Description :
**         The value to drive on the SS pin. This method is not
**         available if <Automatic mode> of SS pin is enabled or
**         <Strobe mode> of SS pin is enabled. This is available if <SS
**         pin direction> is set to Output.
**     Parameters  :
**         NAME            - DESCRIPTION
**         Val             - Output value. Possible values:
**                           <false> - logical "0" (Low level)
**                           <true> - logical "1" (High level)
**     Returns     : Nothing
** ===================================================================
*/
/*
void Resolver_PutSSVal(void)

**  This method is implemented as a macro. See Resolver.h file.  **
*/

/*
** ===================================================================
**     Method      :  Resolver_Init (component SynchroMaster)
**
**     Description :
**         Initializes the associated peripheral(s) and the beans 
**         internal variables. The method is called automatically as a 
**         part of the application initialization code.
**         This method is internal. It is used by Processor Expert only.
** ===================================================================
*/
void Resolver_Init(void)
{
  /* QSPI0_SCTRL: SPR=4,DSO=0,ERRIE=0,MODFEN=0,SPRIE=0,SPMSTR=1,CPOL=1,CPHA=1,SPE=0,SPTIE=0,SPRF=0,OVRF=0,MODF=1,SPTE=0 */
  setReg(QSPI0_SCTRL,0x81C2);          /* Set control register */
  /* QSPI0_DSCTRL: WOM=0,??=0,??=0,BD2X=0,SSB_IN=0,SSB_DATA=1,SSB_ODM=0,SSB_AUTO=0,SSB_DDR=1,SSB_STRB=0,SSB_OVER=0,SPR3=0,DS=0x0B */
  setReg(QSPI0_DSCTRL,0x048B);         /* Set data size and control register */
  /* QSPI0_DELAY: ??=0,??=0,??=0,WAIT=1 */
  setReg(QSPI0_DELAY,0x01);            /* Set data size and control register */
  SerFlag = 0;                         /* Reset all flags */
  EnUser = FALSE;                      /* Disable device */
  HWEnDi();                            /* Enable/disable device according to the status flags */
}

/* END Resolver. */

/*
** ###################################################################
**
**     This file was created by Processor Expert 3.00 [04.35]
**     for the Freescale 56800 series of microcontrollers.
**
** ###################################################################
*/
